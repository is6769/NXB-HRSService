# HRS-сервис 

## Описание

HRS-сервис — это компонент телекоммуникационной биллинговой системы, отвечающий за тарификацию звонков по различным тарифным планам и правилам, а также управление тарифами абонентов.

## Назначение

HRS-сервис выполняет следующие функции:
- Получение данных о звонках от BRT-сервиса через RabbitMQ
- Расчет стоимости звонков по правилам тарифных планов
- Управление лимитами и использованием пакетов услуг
- Автоматическая тарификация по истечении периода тарифа
- Выставление счетов и отправка их обратно в BRT-сервис
- Предоставление API для назначения тарифов абонентам

## Процесс тарификации вызовов

### Получение данных о вызове из RabbitMQ

1. Метод `consumeCallUsageAndSendBill()` в `TarifficationUsageConsumerService` получает объект `UsageWithMetadataDTO` через канал `${const.rabbitmq.tariffication.CALL_USAGE_QUEUE_NAME}`
2. Полученные данные передаются в метод `chargeCall()` сервиса `TariffService` для расчета стоимости

### Алгоритм тарификации

Метод `chargeCall()` в `TariffService` выполняет следующие шаги:

1. Получает текущий тарифный план абонента из `SubscriberTariff`
2. Получает список пакетов услуг для данного тарифного плана (упорядоченных по приоритету)
3. Для каждого пакета услуг проверяет правила тарификации:
   - Если пакет не имеет лимита, применяется поминутная тарификация (пакет правил типа RATE)
   - Если пакет имеет лимит (пакет правил типа LIMIT):
     - Проверяет доступное количество минут в пакете для абонента
     - Если минут достаточно, применяет тарификацию по пакету
     - Если минут недостаточно, разбивает звонок на части (в пределах пакета и за его пределами)
     - Каждая часть тарифицируется отдельно
4. Суммирует стоимость всех частей звонка
5. Формирует объект `TarifficationBillDTO` с информацией о стоимости звонка

### Проверка правил тарификации

Класс `RuleFinderService` отвечает за поиск применимых правил тарификации:

1. Метод `findRuleThatMatchesConditionAndType()` находит правило нужного типа (LIMIT, RATE, COST), удовлетворяющее условиям
2. Метод `cdrMatchesCondition()` проверяет соответствие параметров звонка условиям правила, поддерживая:
   - Простые условия сравнения полей (equals, not_equals)
   - Логические операторы (and, or)
   - Специальные условия (always_true)

### Расчет стоимости звонка

Метод `calculateCallPriceAccordingToRule()` вычисляет стоимость звонка на основе правила тарификации:
- Для правил типа RATE: стоимость минуты * длительность в минутах
- Для правил внутри пакета с лимитом: обычно стоимость равна 0, но учитывается использование лимита

### Обновление использования пакетов

При тарификации звонка в пределах пакета с лимитом:
1. Получает текущее использование пакета для абонента
2. Увеличивает счетчик использованных минут
3. Сохраняет обновленные данные в базе

### Отправка счета

После расчета стоимости звонка:
1. Формируется объект `TarifficationBillDTO` с информацией о стоимости
2. Счет отправляется в BRT-сервис через RabbitMQ (метод `produceBill()`)
3. Используется обмен `${const.rabbitmq.bills.BILLS_EXCHANGE_NAME}`
4. С ключом маршрутизации `${const.rabbitmq.bills.BILLS_ROUTING_KEY}`

## Управление тарифами абонентов

### Назначение тарифа абоненту

Метод `setTariffForSubscriber()` в `TariffService`:

1. Находит выбранный тариф в базе данных
2. Если у абонента уже есть тариф, очищает все данные о текущем тарифе
3. Создает новую запись `SubscriberTariff`, связывающую абонента с тарифом
4. Устанавливает даты начала и окончания цикла тарификации
5. Для всех пакетов услуг с лимитами инициализирует счетчики использования
6. При наличии фиксированной стоимости тарифа (правило COST) выставляет счет

### Периодическая тарификация

Метод `chargeExpiredSubscribersTariffs()` обрабатывает окончание срока действия тарифа:

1. Находит все `SubscriberTariff` с истекшим сроком действия (текущая дата > cycleEnd)
2. Для каждого абонента с истекшим сроком:
   - Повторно назначает тот же тариф (продлевает на новый период)
   - Выставляет абонентскую плату

## Управление системным временем

Сервис работает со специальным системным временем, которое может отличаться от реального:

1. Системное время хранится в таблице `system_datetime`
2. Метод `getSystemDatetime()` возвращает текущее системное время
3. Метод `setSystemDatetime()` обновляет системное время (только вперед)
4. При обработке каждого звонка время обновляется до времени окончания звонка


## Технические детали

### Конфигурационные параметры

- `const.rabbitmq.tariffication.CALL_USAGE_QUEUE_NAME`: имя очереди для получения данных о звонках
- `const.rabbitmq.tariffication.CALL_USAGE_ROUTING_KEY`: ключ маршрутизации для данных о звонках
- `const.rabbitmq.tariffication.TARIFFICATION_EXCHANGE_NAME`: имя обмена для тарификации
- `const.rabbitmq.bills.BILLS_QUEUE_NAME`: имя очереди для отправки счетов
- `const.rabbitmq.bills.BILLS_EXCHANGE_NAME`: имя обмена для счетов
- `const.rabbitmq.bills.BILLS_ROUTING_KEY`: ключ маршрутизации для счетов

### Используемые технологии

- Фреймворк: Spring Boot
- БД: PostgreSQL
- Миграции БД: Liquibase
- Очередь сообщений: RabbitMQ
- Сервисная регистрация: Eureka
- Конфигурация: Spring Cloud Config
- REST API: Spring Web
