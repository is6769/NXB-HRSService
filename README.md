# Сервис HRS

## Описание

HRS-сервис (High performance Rating System) — это компонент телекоммуникационной биллинговой системы, отвечающий за тарификацию звонков по различным тарифным планам и правилам, а также управление тарифами абонентов.

## Назначение

HRS-сервис выполняет следующие функции:
- Тарификация звонков по правилам тарифных планов
- Расчет стоимости звонков с учетом пакетов услуг и лимитов
- Управление тарифными планами абонентов
- Отслеживание использования пакетов услуг
- Автоматическое продление тарифов по окончании их срока действия
- Выставление счетов за использованные услуги

## Логика работы

### Тарификация звонков

1. Сервис получает данные о звонке через RabbitMQ (`TarifficationUsageConsumerService`)
2. Данные передаются в метод `chargeCall()` сервиса `TariffService`
3. Для расчета стоимости звонка выполняются следующие шаги:
   - Проверяется наличие активного тарифа у абонента
   - Обновляется системное время согласно времени окончания звонка
   - Обрабатываются все истекшие тарифы абонентов
   - Получается список пакетов тарифа, отсортированных по приоритету
   - Для каждого пакета проверяется применимость правил тарификации
   - При наличии лимита проверяется его доступный остаток
   - В зависимости от типа пакета и остатка лимита:
     - Если лимит исчерпан, звонок тарифицируется по следующему пакету
     - Если лимит частично доступен, звонок разбивается и тарифицируется по частям
     - При отсутствии лимита применяется поминутная тарификация
   - После расчета стоимости формируется объект счета `TarifficationBillDTO`
   - Счет отправляется в BRT-сервис через RabbitMQ

### Детальный алгоритм тарификации

Алгоритм тарификации выполняется для каждого звонка и включает следующие шаги:

1. **Валидация входных данных:**
   - Проверка наличия обязательных полей в метаданных звонка (finishDateTime, durationInMinutes)
   - Проверка наличия активного тарифа у абонента
   - Проверка активности найденного тарифа

2. **Подготовка системного контекста:**
   - Обновление системного времени до времени окончания звонка
   - Проверка и обработка всех тарифов с истекшим сроком действия

3. **Отбор релевантных пакетов услуг:**
   - Получение всех тарифных пакетов типа "MINUTES" для тарифа абонента
   - Сортировка пакетов по приоритету (чем меньше значение, тем выше приоритет)

4. **Поиск подходящих правил тарификации:**
   - Последовательный перебор пакетов услуг по приоритету
   - Для каждого пакета получаются все правила тарификации
   - С помощью `RuleFinderService` выполняется поиск правил типа LIMIT и RATE

5. **Обработка звонка без лимитов:**
   - Если для пакета не найдено правило LIMIT, используется поминутная тарификация (RATE)
   - Используется правило RATE, соответствующее условиям звонка (тип звонка, оператор и т.д.)
   - Стоимость рассчитывается как: величина правила * длительность звонка в минутах
   - Формируется счёт для BRT-сервиса

6. **Обработка звонка с лимитом:**
   - Проверка наличия `SubscriberPackageUsage` для абонента и пакета услуг
   - Сравнение использованных минут с лимитом пакета
   - Если остаток минут больше длительности звонка:
     - Используется правило RATE (обычно с нулевой стоимостью для бесплатных минут)
     - Увеличивается счетчик использованных минут
     - Формируется счет с соответствующей стоимостью
   - Если остаток минут меньше длительности звонка:
     - Звонок разбивается на две части: в пределах лимита и за пределами лимита
     - Первая часть тарифицируется по текущему пакету
     - Для второй части рекурсивно вызывается метод `chargeCall()`, но с измененной длительностью
     - Итоговый счет объединяет результаты тарификации обеих частей

7. **Обработка звонка при исчерпании всех пакетов:**
   - Если ни один пакет не подходит для тарификации звонка, генерируется исключение `CannotChargeCallException`

### Поиск применимых правил тарификации

1. Класс `RuleFinderService` проверяет правила на соответствие условиям звонка
2. Метод `findRuleThatMatchesConditionAndType()` находит правило нужного типа (LIMIT, RATE, COST)
3. Поддерживаются следующие типы условий:
   - `always_true` - всегда истинно
   - `field` - сравнение значения поля в метаданных звонка
   - `and`/`or` - логическое объединение условий
4. Операторы сравнения: `equals`, `not_equals`

### Управление тарифами абонентов

1. Метод `setTariffForSubscriber()` назначает тарифный план абоненту:
   - Проверяется существование выбранного тарифа
   - Если у абонента уже есть тариф, он удаляется вместе с использованием пакетов
   - Создается новая связь абонента с тарифом (`SubscriberTariff`)
   - Устанавливаются даты начала и окончания цикла тарифа
   - Для каждого пакета с лимитом инициализируются счетчики использования
   - Сервис выставляет счет за подключение тарифа (если есть правило COST)

2. Метод `chargeExpiredSubscribersTariffs()` обрабатывает истекшие тарифы:
   - Находит все `SubscriberTariff` с истекшим сроком действия
   - Для каждого истекшего тарифа осуществляет продление на новый период
   - Выставляет счет за продление тарифа

### Системное время

1. Сервис использует специальное системное время, которое может отличаться от реального
2. Время хранится в таблице `system_datetime` и может продвигаться вперед при обработке звонков
3. Это позволяет корректно обрабатывать исторические данные и тестировать биллинг

## API Endpoints

### Управление тарифами абонентов

- `PUT /subscribers/{subscriberId}/tariff/{tariffId}` - Назначение тарифа абоненту
  - Опциональный параметр `systemDatetime` для указания времени действия тарифа
  - Возвращает сообщение об успешной установке тарифа

- `GET /subscribers/{subscriberId}/tariff` - Получение информации о тарифе абонента
  - Возвращает объект `TariffDTO` с полной информацией о текущем тарифе абонента

### Системное время

- `GET /systemDatetime` - Получение текущей метки системного времени

## Взаимодействие с RabbitMQ

### Получение данных о звонках

1. Сервис подписан на очередь `${const.rabbitmq.tariffication.CALL_USAGE_QUEUE_NAME}`
2. Данные приходят в формате `UsageWithMetadataDTO`, содержащем:
   - ID абонента
   - Метаданные звонка (тип звонка, длительность, время начала/окончания и др.)

### Отправка счетов

1. Расчитанные счета отправляются через RabbitMQ в BRT-сервис
2. Используется обмен `${const.rabbitmq.bills.BILLS_EXCHANGE_NAME}`
3. Маршрутизация по ключу `${const.rabbitmq.bills.BILLS_ROUTING_KEY}`
4. Данные передаются в формате `TarifficationBillDTO`

## Модели данных

### Основные сущности

- **Tariff** - Тарифный план с базовыми характеристиками
- **ServicePackage** - Пакет услуг в составе тарифа (минуты, SMS, интернет)
- **TariffPackage** - Связь между тарифом и пакетом услуг с приоритетом
- **PackageRule** - Правило тарификации (лимиты, стоимость, условия)
- **SubscriberTariff** - Связь между абонентом и тарифом с указанием периода
- **SubscriberPackageUsage** - Использование абонентом пакета услуг (израсходовано/доступно)
- **ConditionNode** - Условие применения правила тарификации
- **SystemDatetime** - Хранение системной даты-времени для биллинга

### Перечисления

- **ServiceType** - Типы услуг (MINUTES, SMS, COST, INTERNET)
- **RuleType** - Типы правил тарификации (LIMIT, RATE, COST)

## Обработка ошибок

Реализован глобальный обработчик исключений `RestExceptionsHandler`, который:
- Обрабатывает специфические исключения и возвращает соответствующие HTTP-статусы
- Формирует единообразный ответ в формате `ExceptionDTO`
- Поддерживает следующие типы ошибок:
  - `CannotChargeCallException` - Невозможно тарифицировать звонок (404)
  - `InvalidCallMetadataException` - Некорректные метаданные звонка (400)
  - `NoSuchSubscriberTariffException` - Тариф абонента не найден (400)
  - `NoSuchTariffException` - Запрошенный тариф не существует (404)
  - `SubscriberWithInactiveTariffException` - Неактивный тариф абонента (400)
  - `UnsupportedConditionTypeException` - Неподдерживаемый тип условия (500)
  - `UnsupportedOperatorException` - Неподдерживаемый оператор сравнения (500)

## Технические детали

### Технологический стек

- **Java 17**
- **Spring Boot 3.4**
- **Spring Cloud**:
  - Eureka Client для регистрации сервиса
  - Config Client для централизованной конфигурации
- **Spring Data JPA** для работы с базой данных
- **Spring AMQP** для взаимодействия через RabbitMQ
- **PostgreSQL** в качестве СУБД
- **Lombok** для уменьшения шаблонного кода
- **SLF4J** для логирования

### База данных

**PostgreSQL**
- JDBC URL: `jdbc:postgresql://localhost:5433/hrs-db`
- Пользователь: `postgres`
- Пароль: `postgres`
- Схема: `public`

В контейнерной среде:
- JDBC URL: `jdbc:postgresql://hrs-db:5432/hrs-db`

### Мониторинг

Сервис включает компонент мониторинга `EurekaRegistrationHealthIndicator`, который:
- Проверяет успешность регистрации сервиса в Eureka
- Предоставляет информацию о статусе регистрации через Actuator Health API
- Помогает в диагностике проблем связи с сервером обнаружения служб
